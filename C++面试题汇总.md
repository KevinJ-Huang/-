```cpp
1.请用简单的语言告诉我C++ 是什么？
答：C++是在C语言的基础上开发的一种面向对象编程语言，应用广泛。C++支持多种编程范式 －－面向对象编程、泛型编程和过程化编程。 
其编程领域众广，常用于系统开发，引擎开发等应用领域，是最受广大程序员受用的最强大编程语言之一,支持类：类、封装、重载等特性!

2.C和C++的区别？
答：c++在c的基础上增添类，C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出
（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。

3.什么是多态？
答：多态是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态。

4.STL库用过吗？常见的STL容器有哪些？算法用过哪几个？
STL包括两部分内容：容器和算法。（重要的还有融合这二者的迭代器）容器，即存放数据的地方。比如array等。
在STL中，容器分为两类：序列式容器和关联式容器。
序列式容器，其中的元素不一定有序，但都可以被排序。如：vector、list、deque、stack、queue、heap、priority_queue、slist；
关联式容器，内部结构基本上是一颗平衡二叉树。所谓关联，指每个元素都有一个键值和一个实值，元素按照一定的规则存放。如：RB-tree、set、map、multiset、multimap、hashtable、hash_set、hash_map、hash_multiset、hash_multimap。

迭代器是STL的精髓，我们这样描述它：迭代器提供了一种方法，使它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构。它将容器和算法分开，好让这二者独立设计。

5.const知道吗？解释其作用。
01.const 修饰类的成员变量，表示成员常量，不能被修改。
02.const修饰函数承诺在本函数内部不会修改类内的数据成员，不会调用其它非 const 成员函数。
03.如果 const 构成函数重载，const 对象只能调用 const 函数，非 const 对象优先调用非 const 函数。
04.const 函数只能调用 const 函数。非 const 函数可以调用 const 函数。
05.类体外定义的 const 成员函数，在定义和声明处都需要 const 修饰符。

6. 类的static变量在什么时候初始化？函数的static变量在什么时候初始化？
类的静态成员变量在类实例化之前就已经存在了，并且分配了内存。函数的static变量在执行此函数时进行初始化。

7.解释下封装、继承和多态？
一、封装：
封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。
封装的意义在于保护或者防止代码（数据）被我们无意中破坏。
二、继承：
继承主要实现重用代码，节省开发时间。
子类可以继承父类的一些东西。
三、多态
多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。

8.new和malloc的区别？
01、malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
02、对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。
03、由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。
注意new/delete不是库函数。
04、C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。
05、new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void指针。

9.构造函数不能为虚函数，析构函数是虚函数

10.strcut和class的区别
01.默认的继承访问权。class默认的是private,strcut默认的是public。
02.默认访问权限：struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。
03.“class”这个关键字还用于定义模板参数，就像“typename”。但关建字“struct”不用于定义模板参数

11.const与#define的区别
01.const常量有数据类型，而define定义宏常量没有数据类型。
02.部分调度工具可以对const常量进行调度，但不能对宏常量进行调度
03.define宏是在预处理阶段展开，const常量则是编译运行阶段使用；
04.define宏仅仅是展开，有几个地方使用则展开几次，不分配内存；const常量会在内存中分配地址
05.define定义的常量在内存中有若干个拷贝；const定义的常量在程序运行过程中只有一份拷贝，甚至不为普通const常量分配存储空间，而是将它们保存在符号表中，相当于没有了读内存的操作，使得效率也很高

12.c++ map与unordered_map区别
map： map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的
unordered_map: unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。
对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map；对于那些有顺序要求的问题，用map会更高效一些

13.STL中vector的实现原理
vector的数据安排以及操作方式与array非常类似。两者的唯一差别在于空间的运用的灵活性。
vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新的元素。vector采用的数据结构很简单：线性的连续空间。
为了降低空间配置时候的速度，vector实际配置的大小可能比客户端需求量更大一些，以备将来可能的扩充。
一旦vector空间重新配置，则指向原来vector的所有迭代器都失效了，因为vector的地址改变了。
vector其中一个特点：内存空间只会增长，不会减小，援引C++ Primer：为了支持快速的随机访问，vector容器的元素以连续方式存放，每一个元素都紧挨着前一个元素存储。

14.面向对象的三个基本特征
面向对象的三个基本特征是：封装、继承、多态。其中，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！

15.emplace_back() 和 push_back 的区别
在引入右值引用，转移构造函数，转移复制运算符之前，通常使用push_back()向容器中加入一个右值元素（临时对象）的时候，首先会调用构造函数构造这个临时对象，然后需要调用拷贝构造函数将这个临时对象放入容器中。原来的临时变量释放。这样造成的问题是临时变量申请的资源就浪费。 
引入了右值引用，转移构造函数（请看这里）后，push_back()右值时就会调用构造函数和转移构造函数。 
在这上面有进一步优化的空间就是使用emplace_back


```
