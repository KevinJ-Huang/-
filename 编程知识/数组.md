```cpp
1.数组就是矩阵，矩阵就是数组，这种说法（ ）。
答：都错
原因：数组中的元素可以是字符等，矩阵中的只能是数。

2.下列哪两个数据结构，同时具有较高的查找和删除性能？（）
有序数组，有序链表，AVL树，Hash表
答：平衡二叉树的查找，插入和删除性能都是O(logN)，其中查找和删除性能较好；哈希表的查找、插入和删除性能都是O(1)，都是最好的。

3.数组优于链表的特点? 
答：存储空间小 的意思是 占用的存储空间少,由于链表结点需要持有额外的指针，因此所占用的空间较数组更大

4.数据结构具有记忆功能的是栈

5.在Visual C++和Mingw64平台，short a[100]，sizeof(a) 返回
答：200
原因：sizeof 返回的值表示的含义如下（单位字节）：
     数组 —— 编译时分配的数组空间大小； 
     指针 —— 存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为 4 ）； 
     类型 —— 该类型所占的空间大小； 
     对象 —— 对象的实际占用空间大小； 
     函数 —— 函数的返回类型所占的空间大小。函数的返回类型不能是 void 
short的大小为2字节；short [100]的大小就是200字节

6.在C语言中，顺序存储长度为3的字符串，需要占用（  4  ）个字节。
答：C语言中，字符串默认每个占用1字节，末尾还有'\0'，所以一共是4字节

7.对n个记录的线性表进行快速排序为减少算法的递归深度，每次分区后,先处理较短的部分
答：如果按长的递归优先的话，那么短的递归会一直保存在栈中，直到长的处理完。短的优先的话，长的递归调用没有进行，他是作为一个整体保存在栈中的，所以递归栈中的保留的递归数据少一些。

8.静态链表是用数组存储节点数据，模拟链表的实现，但是没有用到指针。每个数组节点包括两部分：data域和cursor（游标）域。data存储数据，cursor指明下个元素在数组中的下标。
（1）存取第i个元素时，需要从头遍历到i-1和元素，由第i-1个节点的cursor，才能知道第i个元素存储的位置，因此和i是相关的。
（2）使用数组对元素进行存储，在定义时大小已经确定。
（3）插入和删除操作无需移动元素，只需要修改cursor游标的值即可，就像修改动态链表中的指针一样。

9.稀疏矩阵一般的压缩存储方法有两种,即三元组和十字链表。

10.Char x[]=”abcdefg”;Char y[]={‘a’,’b’,’c’,’d’,’e’,’f’,’g’};
答：数组X的sizeof运算值大于数组Y的sizeof运算值
原因：x如此定义会在后面添加\0,所以x比y多一个结束符号

11. unshift()：向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度

12.若有说明：a[3][4];，则数组 a 中初值无法确定，系统为所定义的数组在内存中开辟了已连续的存储单元，但这些存储单元中没有确定的值

13.索引顺序查找又称为分块查找，是介于顺序查找和二分查找之间的一种查找方法

14.广义表的元素可以为空

15.int[,] a = {{1,2,3}}；错误，大括号里少个逗号

16.double * array [8],array是一个数组，数组的每一个元素是指向双精度实型数据的指针

17.数组可看作基本线性表的一种推广，因此与线性表一样，可以对它进行插入、删除等操作，这样的说法正确吗？
不正确,数组越界不能插入

18.采用压缩存储后，对称矩阵是所有特殊矩阵中存储空间节约最多的。
不正确，稀疏矩阵才是。

19.循环队列
进队：队尾指针(rear+1)%m
出队：对头指针(front+1)%m
在队列中插入一个队列元素称为入队， 从队列中删除一个队列元素称为出队。 队列先进先出，所以出队头指针+1

20.
1、int(*p)[4];------ptr为指向含4个元素的一维整形数组的指针变量（是指针）
2、int *p[4];-------定义指针数组p，它由4个指向整型数据的指针元素组成（是数组）
3、int(*)[4];--------实际上可以看作是一种数据类型。也就是第一个（int(*p)[4];）

21.有一个100*90的稀疏矩阵,非0元素有10个,设每个整型数占2字节,则用三元组表示该矩阵时,所需的字节数是()
将非零元素所在行、列、非零元素的值构成一个三元组（i，j，v） ；
对于该题：
每个非零元素占3*2=6个字节，共10个非零元素，需6*10 = 60 个字节；
此外，还一般要用三个整数来存储矩阵的行数、列数和总元素个数，又需要3*2 = 6个字节；
总共：60 + 6 = 66 个字节。

22.
```


